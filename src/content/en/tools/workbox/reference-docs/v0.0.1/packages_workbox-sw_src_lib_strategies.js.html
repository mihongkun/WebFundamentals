<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="_project.yaml" />
  <meta name="book_path" value="_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Source: packages/workbox-sw/src/lib/strategies.js</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: packages/workbox-sw/src/lib/strategies.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>import {
  CacheFirst, CacheOnly, NetworkFirst,
  NetworkOnly, StaleWhileRevalidate,
} from &#x27;../../../workbox-runtime-caching/src/index.js&#x27;;
import {CacheExpirationPlugin} from
  &#x27;../../../workbox-cache-expiration/src/index.js&#x27;;
import {BroadcastCacheUpdatePlugin} from
  &#x27;../../../workbox-broadcast-cache-update/src/index.js&#x27;;
import {CacheableResponsePlugin} from
  &#x27;../../../workbox-cacheable-response/src/index.js&#x27;;
import {RequestWrapper} from &#x27;../../../workbox-runtime-caching/src/index.js&#x27;;

/**
 * This is a simple class used to namespace the supported caching strategies in
 * workbox-sw.
 *
 * You would never access this class directly but instead use with
 * &#x60;swlib.strategies.&amp;lt;Strategy Name&gt;&#x60;.
 *
 * @memberof module:workbox-sw
 */
class Strategies {
  /**
   * This constructor will configure shared options across each strategy.
   * @param {String} [input.cacheId] The cacheId to be applied to the run
   * time strategies cache names.
   */
  constructor({cacheId} &#x3D; {}) {
    this._cacheId &#x3D; cacheId;
  }

  /**
   * A [cache first](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network)
   * run-time caching strategy.
   *
   * @example
   * const &#x3D; new goog.SWLib();
   * const cacheFirstStrategy &#x3D; swlib.strategies.cacheFirst();
   *
   * swlib.router.registerRoute(&#x27;/styles/*&#x27;, cacheFirstStrategy);
   *
   * @param {module:workbox-sw.SWLib.RuntimeStrategyOptions} [options] To define
   * any additional caching or broadcast plugins pass in option values.
   * @return {module:workbox-runtime-caching.CacheFirst} A CacheFirst handler.
   */
  cacheFirst(options) {
    return this._getCachingMechanism(CacheFirst, options);
  }

  /**
   * A [cache only](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only)
   * run-time caching strategy.
   *
   * @example
   * const swlib &#x3D; new goog.SWLib();
   * const cacheOnlyStrategy &#x3D; swlib.strategies.cacheOnly();
   *
   * swlib.router.registerRoute(&#x27;/styles/*&#x27;, cacheOnlyStrategy);
   *
   * @param {module:workbox-sw.SWLib.RuntimeStrategyOptions} [options] To define
   * any additional caching or broadcast plugins pass in option values.
   * @return {module:workbox-runtime-caching.CacheOnly} The caching handler
   * instance.
   */
  cacheOnly(options) {
    return this._getCachingMechanism(CacheOnly, options);
  }

  /**
   * A [network first](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache)
   * run-time caching strategy.
   *
   * @example
   * const swlib &#x3D; new goog.SWLib();
   * const networkFirstStrategy &#x3D; swlib.strategies.networkFirst();
   *
   * swlib.router.registerRoute(&#x27;/blog/&#x27;, networkFirstStrategy);
   *
   * @param {module:workbox-sw.SWLib.RuntimeStrategyOptions} [options] To define
   * any additional caching or broadcast plugins pass in option values.
   * @return {module:workbox-runtime-caching.NetworkFirst} The caching handler
   * instance.
   */
  networkFirst(options) {
    return this._getCachingMechanism(NetworkFirst, options);
  }

  /**
   * A [network only](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only)
   * run-time caching strategy.
   *
   * @example
   * const swlib &#x3D; new goog.SWLib();
   * const networkOnlyStrategy &#x3D; swlib.strategies.networkOnly();
   *
   * swlib.router.registerRoute(&#x27;/admin/&#x27;, networkOnlyStrategy);
   *
   * @param {module:workbox-sw.SWLib.RuntimeStrategyOptions} [options] To define
   * any additional caching or broadcast plugins pass in option values.
   * @return {module:workbox-runtime-caching.NetworkOnly} The caching handler
   * instance.
   */
  networkOnly(options) {
    return this._getCachingMechanism(NetworkOnly, options);
  }

  /**
   * A [stale while revalidate](https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate)
   * run-time caching strategy.
   *
   * @example
   * const swlib &#x3D; new goog.SWLib();
   * const staleWhileRevalidateStrategy &#x3D;
   *  swlib.strategies.staleWhileRevalidate();
   *
   * swlib.router.registerRoute(&#x27;/styles/*&#x27;, staleWhileRevalidateStrategy);
   *
   * @param {module:workbox-sw.SWLib.RuntimeStrategyOptions} [options] To define
   * any additional caching or broadcast plugins pass in option values.
   * @return {module:workbox-runtime-caching.StaleWhileRevalidate} The caching
   * handler instance.
   */
  staleWhileRevalidate(options) {
    return this._getCachingMechanism(StaleWhileRevalidate, options);
  }

  /**
   * This method will add plugins based on options passed in by the
   * developer.
   *
   * @private
   * @param {Class} HandlerClass The class to be configured and instantiated.
   * @param {Object} [options] Options to configure the handler.
   * @return {Handler} A handler instance configured with the appropriate
   * behaviours
   */
  _getCachingMechanism(HandlerClass, options &#x3D; {}) {
    const pluginParamsToClass &#x3D; {
      &#x27;cacheExpiration&#x27;: CacheExpirationPlugin,
      &#x27;broadcastCacheUpdate&#x27;: BroadcastCacheUpdatePlugin,
      &#x27;cacheableResponse&#x27;: CacheableResponsePlugin,
    };

    const wrapperOptions &#x3D; {
      plugins: [],
      cacheId: this._cacheId,
    };

    if (options[&#x27;cacheName&#x27;]) {
      wrapperOptions[&#x27;cacheName&#x27;] &#x3D; options[&#x27;cacheName&#x27;];
    }

    // Iterate over known plugins and add them to Request Wrapper options.
    const pluginKeys &#x3D; Object.keys(pluginParamsToClass);
    pluginKeys.forEach((pluginKey) &#x3D;&gt; {
      if (options[pluginKey]) {
        const PluginClass &#x3D; pluginParamsToClass[pluginKey];
        const pluginParams &#x3D; options[pluginKey];

        wrapperOptions.plugins.push(new PluginClass(pluginParams));
      }
    });

    // Add custom plugins.
    if (options.plugins) {
      options.plugins.forEach((plugin) &#x3D;&gt; {
        wrapperOptions.plugins.push(plugin);
      });
    }

    return new HandlerClass({
      requestWrapper: new RequestWrapper(wrapperOptions),
    });
  }
}

export default Strategies;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>