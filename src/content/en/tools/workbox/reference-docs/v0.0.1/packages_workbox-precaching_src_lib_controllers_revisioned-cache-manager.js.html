<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="_project.yaml" />
  <meta name="book_path" value="_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Source: packages/workbox-precaching/src/lib/controllers/revisioned-cache-manager.js</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: packages/workbox-precaching/src/lib/controllers/revisioned-cache-manager.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>import ErrorFactory from &#x27;../error-factory&#x27;;
import BaseCacheManager from &#x27;./base-cache-manager&#x27;;
import RevisionDetailsModel from &#x27;../models/revision-details-model&#x27;;
import {defaultRevisionedCacheName} from &#x27;../constants&#x27;;
import StringPrecacheEntry from
  &#x27;../models/precache-entries/string-precache-entry&#x27;;
import ObjectPrecacheEntry from
  &#x27;../models/precache-entries/object-precache-entry&#x27;;
import assert from &#x27;../../../../../lib/assert&#x27;;
import logHelper from &#x27;../../../../../lib/log-helper&#x27;;

/**
 * This class extends a lot of the internal methods from BaseCacheManager
 * to manage caching of revisioned assets.
 *
 * @private
 * @memberof module:workbox-precaching
 * @extends {module:workbox-precaching.BaseCacheManager}
 */
class RevisionedCacheManager extends BaseCacheManager {
  /**
   * Constructor for RevisionedCacheManager
   * @param {Object} input
   * @param {String} [input.cacheName] Define the cache used to stash these
   * entries.
   * @param {String} [input.cacheId] The cacheId can be used to ensure that
   * multiple projects sharing &#x60;http://localhost&#x60; have unique cache names.
   * @param {Array&amp;lt;Object&gt;} [input.plugins] Any plugins that should be
   * invoked by the underlying &#x60;RequestWrapper&#x60;.
   */
  constructor(input &#x3D; {}) {
    input.cacheName &#x3D; input.cacheName || defaultRevisionedCacheName;

    super(input);

    this._revisionDetailsModel &#x3D; new RevisionDetailsModel();
  }

  /**
   * This method will add the entries to the install list.
   * This will manage duplicate entries and perform the caching during
   * the install step.
   *
   * @example
   *
   * revisionedManager.addToCacheList({
   *   revisionedFiles: [
   *     &#x27;/styles/hello.1234.css&#x27;,
   *     {
   *       url: &#x27;/images/logo.png&#x27;,
   *       revision: &#x27;abcd1234&#x27;
   *     }
   *   ]
   * });
   *
   * @param {Array&amp;lt;String|Object&gt;} rawEntries A raw entry that can be
   * parsed into a BaseCacheEntry.
   */
  addToCacheList({revisionedFiles} &#x3D; {}) {
    assert.isInstance({revisionedFiles}, Array);
    super._addEntries(revisionedFiles);

    const urlsWithoutRevisionFields &#x3D; revisionedFiles
      .filter((entry) &#x3D;&gt; typeof entry &#x3D;&#x3D;&#x3D; &#x27;string&#x27;);
    if (urlsWithoutRevisionFields.length &gt; 0) {
      logHelper.debug({
        that: this,
        message: &#x60;Some precache entries are URLs without separate revision
          fields. If the URLs themselves do not contain revisioning info,
          like a hash or a version number, your users won&#x27;t receive updates.&#x60;,
        data: {
          &#x27;URLs without revision fields&#x27;:
            JSON.stringify(urlsWithoutRevisionFields),
          &#x27;Examples of safe, versioned URLs&#x27;:
            &#x60;&#x27;/path/file.abcd1234.css&#x27; or &#x27;/v1.0.0/file.js&#x27;&#x60;,
          &#x27;Examples of dangerous, unversioned URLs&#x27;:
            &#x60;&#x27;index.html&#x27; or &#x27;/path/file.css&#x27; or &#x27;/latest/file.js&#x27;&#x60;,
        },
      });
    }
  }

  /**
   * This method ensures that the file entry in the maniest is valid and
   * can be parsed as a BaseCacheEntry.
   *
   * @private
   * @abstract
   * @param {String | Object} input Either a URL string
   * or an object with a &#x60;url&#x60;, &#x60;revision&#x60; and optional &#x60;cacheBust&#x60; parameter.
   * @return {BaseCacheEntry} Returns a parsed version of the file entry.
   */
  _parseEntry(input) {
    if (typeof input &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; || input &#x3D;&#x3D;&#x3D; null) {
      throw ErrorFactory.createError(&#x27;invalid-revisioned-entry&#x27;,
        new Error(&#x27;Invalid file entry: &#x27; + JSON.stringify(input))
      );
    }

    let precacheEntry;
    switch(typeof input) {
      case &#x27;string&#x27;:
        precacheEntry &#x3D; new StringPrecacheEntry(input);
        break;
      case &#x27;object&#x27;:
        precacheEntry &#x3D; new ObjectPrecacheEntry(input);
        break;
      default:
        throw ErrorFactory.createError(&#x27;invalid-revisioned-entry&#x27;,
          new Error(&#x27;Invalid file entry: &#x27; +
            JSON.stringify(precacheEntry))
          );
    }

    return precacheEntry;
  }

  /**
   * If a dupe entry exists, check the revision. If the revisions are the same
   * it&#x27;s simply a duplicate entry. If they are different, we have two
   * identical requests with two different revisions which will put this
   * module into a bad state.
   *
   * @private
   * @param {BaseCacheEntry} newEntry The entry that is to be cached.
   * @param {BaseCacheEntry} previousEntry The entry that is currently cached.
   */
  _onDuplicateInstallEntryFound(newEntry, previousEntry) {
    if (previousEntry.revision !&#x3D;&#x3D; newEntry.revision) {
      throw ErrorFactory.createError(
        &#x27;duplicate-entry-diff-revisions&#x27;,
        new Error(&#x60;${JSON.stringify(previousEntry)} &amp;lt;&#x3D;&gt; &#x60; +
          &#x60;${JSON.stringify(newEntry)}&#x60;));
    }
  }

  /**
   * This method confirms with a precacheEntry is already in the cache with the
   * appropriate revision.
   * If the revision is known, the requested &#x60;precacheEntry.revision&#x60; is saved
   * and the cache entry exists for the &#x60;precacheEntry.path&#x60; this method
   * will return true.
   *
   * @private
   * @param {BaseCacheEntry} precacheEntry A entry with &#x60;path&#x60; and &#x60;revision&#x60;
   * parameters.
   * @return {Promise&amp;lt;Boolean&gt;} Returns true if the precacheEntry is already
   * cached, false otherwise.
   */
  async _isAlreadyCached(precacheEntry) {
    const revisionDetails &#x3D; await
      this._revisionDetailsModel.get(precacheEntry.entryID);
    if (revisionDetails !&#x3D;&#x3D; precacheEntry.revision) {
      return false;
    }

    const openCache &#x3D; await this._getCache();
    const cachedResponse &#x3D; await openCache.match(precacheEntry.request);
    return cachedResponse ? true : false;
  }

  /**
   * @private
   * @param {BaseCacheEntry} precacheEntry A file entry with &#x60;path&#x60; and
   * &#x60;revision&#x60; parameters.
   */
  async _onEntryCached(precacheEntry) {
    await this._revisionDetailsModel.put(
      precacheEntry.entryID, precacheEntry.revision);
  }

  /**
   * This method closes the indexdDB helper. This is used for unit testing
   * to ensure cleanup between tests.
   * @private
   */
  _close() {
    this._revisionDetailsModel._close();
  }

  /**
   * Compare the URL&#x27;s and determines which assets are no longer required
   * in the cache.
   *
   * This should be called in the service worker activate event.
   *
   * @return {Promise} Promise that resolves once the cache entries have been
   * cleaned.
   */
  cleanup() {
    return super.cleanup()
    .then(() &#x3D;&gt; {
      return this._close();
    });
  }
}

export default RevisionedCacheManager;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>