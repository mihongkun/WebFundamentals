<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="_project.yaml" />
  <meta name="book_path" value="_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Source: packages/workbox-runtime-caching/src/lib/request-wrapper.js</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: packages/workbox-runtime-caching/src/lib/request-wrapper.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

import ErrorFactory from &#x27;./error-factory&#x27;;
import assert from &#x27;../../../../lib/assert&#x27;;
import {CacheableResponsePlugin} from
  &#x27;../../../workbox-cacheable-response/src/index&#x27;;
import {pluginCallbacks, getDefaultCacheName} from &#x27;./constants&#x27;;
import cleanResponseCopy from &#x27;./clean-response-copy&#x27;;

/**
 * This class is used by the various subclasses of &#x60;Handler&#x60; to configure the
 * cache name and any desired plugins, which is to say classes that implement
 * request lifecycle callbacks.
 *
 * It automatically triggers any registered callbacks at the appropriate time.
 * The current set of plugin callbacks, along with the parameters they&#x27;re
 * given and when they&#x27;re called, is:
 *
 *   - &#x60;cacheWillUpdate({request, response})&#x60;: Called prior to writing an entry
 *   to the cache, allowing the callback to decide whether or not the cache
 *   entry should be written.
 *   - &#x60;cacheDidUpdate({cacheName, oldResponse, newResponse, url})&#x60;: Called
 *   whenever an entry is written to the cache, giving the callback a chance to
 *   notify clients about the update or implement cache expiration.
 *   - &#x60;cacheWillMatch({cachedResponse})&#x60;: Called whenever a response is read
 *   from the cache and is about to be used, giving the callback a chance to
 *   perform validity/freshness checks.
 *   - &#x60;fetchDidFail({request})&#x60;: Called whenever a network request fails.
 *
 * @memberof module:workbox-runtime-caching
 */
class RequestWrapper {
  /**
   * Constructor for RequestWrapper.
   * @param {Object} input
   * @param {string} [input.cacheName] The name of the cache to use for Handlers
   *        that involve caching. If none is provided, a default name that
   *        includes the current service worker scope will be used.
   * @param {Array.&amp;lt;Object&gt;} [input.plugins] Any plugins that should be
   *        invoked.
   * @param {Object} [input.fetchOptions] Values passed along to the
   *        [&#x60;init&#x60;](https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch#Parameters)
   *        of all &#x60;fetch()&#x60; requests made by this wrapper.
   * @param {Object} [input.matchOptions] Values passed along to the
   *        [&#x60;options&#x60;](https://developer.mozilla.org/en-US/docs/Web/API/Cache/match#Parameters)
   *        of all cache &#x60;match()&#x60; requests made by this wrapper.
   */
  constructor({cacheName, cacheId, plugins, fetchOptions, matchOptions} &#x3D; {}) {
    if (cacheId &amp;amp;&amp;amp; (typeof cacheId !&#x3D;&#x3D; &#x27;string&#x27; || cacheId.length &#x3D;&#x3D;&#x3D; 0)) {
      throw ErrorFactory.createError(&#x27;bad-cache-id&#x27;);
    }

    if (cacheName) {
      assert.isType({cacheName}, &#x27;string&#x27;);
      this.cacheName &#x3D; cacheName;
      if (cacheId) {
        this.cacheName &#x3D; &#x60;${cacheId}-${this.cacheName}&#x60;;
      }
    } else {
      this.cacheName &#x3D; getDefaultCacheName({cacheId});
    }

    if (fetchOptions) {
      assert.isType({fetchOptions}, &#x27;object&#x27;);
      this.fetchOptions &#x3D; fetchOptions;
    }

    if (matchOptions) {
      assert.isType({matchOptions}, &#x27;object&#x27;);
      this.matchOptions &#x3D; matchOptions;
    }

    this.plugins &#x3D; new Map();

    if (plugins) {
      assert.isArrayOfType({plugins}, &#x27;object&#x27;);

      plugins.forEach((plugin) &#x3D;&gt; {
        for (let callbackName of pluginCallbacks) {
          if (typeof plugin[callbackName] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;) {
            if (!this.plugins.has(callbackName)) {
              this.plugins.set(callbackName, []);
            } else if (callbackName &#x3D;&#x3D;&#x3D; &#x27;cacheWillUpdate&#x27;) {
              throw ErrorFactory.createError(
                &#x27;multiple-cache-will-update-plugins&#x27;);
            } else if (callbackName &#x3D;&#x3D;&#x3D; &#x27;cacheWillMatch&#x27;) {
              throw ErrorFactory.createError(
                &#x27;multiple-cache-will-match-plugins&#x27;);
            }
            this.plugins.get(callbackName).push(plugin);
          }
        }
      });
    }

    if (this.plugins.has(&#x27;cacheWillUpdate&#x27;)) {
      this._userSpecifiedCachableResponsePlugin &#x3D;
        this.plugins.get(&#x27;cacheWillUpdate&#x27;)[0];
    }
  }


  /**
   * @private
   * @return {function} The default plugin used to determine whether a
   *         response is cacheable.
   */
  getDefaultCacheableResponsePlugin() {
    // Lazy-construct the CacheableResponsePlugin instance.
    if (!this._defaultCacheableResponsePlugin) {
      this._defaultCacheableResponsePlugin &#x3D;
        new CacheableResponsePlugin({statuses: [200]});
    }
    return this._defaultCacheableResponsePlugin;
  }

  /**
   * Opens a cache and maintains a reference to that cache
   * for future use.
   *
   * @example
   * requestWrapper.getCache()
   * .then((openCache) &#x3D;&gt; {
   *    ...
   * });
   *
   * @return {Promise&amp;lt;Cache&gt;} An open &#x60;Cache&#x60; instance based on the configured
   * &#x60;cacheName&#x60;.
   */
  async getCache() {
    if (!this._cache) {
      this._cache &#x3D; await caches.open(this.cacheName);
    }
    return this._cache;
  }

  /**
   * Wraps &#x60;cache.match()&#x60;, using the previously configured cache name and match
   * options.
   *
   * @example
   * requestWrapper.match({event.request})
   * .then((response) &#x3D;&gt; {
   *   if (!response) {
   *     // No response in cache.
   *     return;
   *   }
   *   ...
   * });
   *
   * @param {Object} input
   * @param {Request|string} input.request The key for the cache lookup.
   * @return {Promise.&amp;lt;Response&gt;} The cached response.
   */
  async match({request}) {
    assert.atLeastOne({request});

    const cache &#x3D; await this.getCache();
    let cachedResponse &#x3D; await cache.match(request, this.matchOptions);

    if (this.plugins.has(&#x27;cacheWillMatch&#x27;)) {
      const plugin &#x3D; this.plugins.get(&#x27;cacheWillMatch&#x27;)[0];
      cachedResponse &#x3D; plugin.cacheWillMatch({request, cache, cachedResponse,
        matchOptions: this.matchOptions});
    }

    return cachedResponse;
  }

  /**
   * Wraps &#x60;fetch()&#x60;, calls all &#x60;requestWillFetch&#x60; before making the network
   * request, and calls any &#x60;fetchDidFail&#x60; callbacks from the
   * registered plugins if the request fails.
   *
   * @example
   * requestWrapper.fetch({
   *   request: event.request
   * })
   * .then((response) &#x3D;&gt; {
   *  ...
   * })
   * .catch((err) &#x3D;&gt; {
   *   ...
   * });
   *
   * @param {Object} input
   * @param {Request|string} input.request The request or URL to be fetched.
   * @return {Promise.&amp;lt;Response&gt;} The network response.
   */
  async fetch({request}) {
    if (typeof request &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
      request &#x3D; new Request(request);
    } else {
      assert.isInstance({request}, Request);
    }

    // If there is a fetchDidFail plugin, we need to save a clone of the
    // original request before it&#x27;s either modified by a requestWillFetch
    // plugin or before the original request&#x27;s body is consumed via fetch().
    const clonedRequest &#x3D; this.plugins.has(&#x27;fetchDidFail&#x27;) ?
      request.clone() : null;

    if (this.plugins.has(&#x27;requestWillFetch&#x27;)) {
      for (let plugin of this.plugins.get(&#x27;requestWillFetch&#x27;)) {
        const returnedPromise &#x3D; plugin.requestWillFetch({request});
        assert.isInstance({returnedPromise}, Promise);
        const returnedRequest &#x3D; await returnedPromise;
        assert.isInstance({returnedRequest}, Request);
        request &#x3D; returnedRequest;
      }
    }

    try {
      return await fetch(request, this.fetchOptions);
    } catch (err) {
      if (this.plugins.has(&#x27;fetchDidFail&#x27;)) {
        for (let plugin of this.plugins.get(&#x27;fetchDidFail&#x27;)) {
          plugin.fetchDidFail({request: clonedRequest.clone()});
        }
      }

      throw err;
    }
  }

  /**
   * Combines both fetching and caching using the previously configured options
   * and calling the appropriate plugins.
   *
   * By default, responses with a status of [2xx](https://fetch.spec.whatwg.org/#ok-status)
   * will be considered valid and cacheable, but this could be overridden by
   * configuring one or more plugins that implement the &#x60;cacheWillUpdate&#x60;
   * lifecycle callback.
   *
   * @example
   * requestWrapper.fetchAndCache({
   *   request: event.request
   * })
   * .then((response) &#x3D;&gt; {
   *  ...
   * })
   * .catch((err) &#x3D;&gt; {
   *   ...
   * });
   *
   * @param {Object} input
   * @param {Request} input.request The request to fetch.
   * @param {boolean} [input.waitOnCache] &#x60;true&#x60; means the method should wait
   *        for the cache.put() to complete before returning. The default value
   *        of &#x60;false&#x60; means return without waiting. It this value is true
   *        and the response can&#x27;t be cached, an error will be thrown.
   * @param {Request} [input.cacheKey] Supply a cacheKey if you wish to cache
   *        the response against an alternative request to the &#x60;request&#x60;
   *        argument.
   * @param {function} [input.cacheResponsePlugin] Allows the
   *        caller to override the default check for cacheability, for
   *        situations in which the cacheability check wasn&#x27;t explicitly
   *        configured when constructing the &#x60;RequestWrapper&#x60;.
   * @param {boolean} [input.cleanRedirects] If true, a &quot;clean&quot; copy of any
   * redirected responses will be added to the cache, since redirected responses
   * [can&#x27;t be used](https://bugs.chromium.org/p/chromium/issues/detail?id&#x3D;669363&amp;amp;desc&#x3D;2#c1)
   * to satisfy navigation requests. Defaults to false.
   * @return {Promise.&amp;lt;Response&gt;} The network response.
   */
  async fetchAndCache(
    {request, waitOnCache, cacheKey, cacheResponsePlugin, cleanRedirects}) {
    assert.atLeastOne({request});

    let cachingComplete;
    const response &#x3D; await this.fetch({request});

    // We need flexibility in determining whether a given response should
    // be added to the cache. There are several possible ways that this logic
    // might be specified, and they&#x27;re given the following precedence:
    // 1. Passing in a &#x60;CacheableResponsePlugin&#x60; to the &#x60;RequestWrapper&#x60;
    //    constructor, which sets this._userSpecifiedCachableResponsePlugin.
    // 2. Passing in a parameter to the fetchAndCache() method (done by certain
    //    runtime handlers, like &#x60;StaleWhileRevalidate&#x60;), which sets
    //    cacheResponsePlugin.
    // 3. The default that applies to anything using the &#x60;RequestWrapper&#x60; class
    //    that doesn&#x27;t specify the custom behavior, which is accessed via
    //    the this.getDefaultCacheableResponsePlugin().
    const effectiveCacheableResponsePlugin &#x3D;
      this._userSpecifiedCachableResponsePlugin ||
      cacheResponsePlugin ||
      this.getDefaultCacheableResponsePlugin();

    // Whichever plugin we&#x27;ve decided is appropriate, we now call its
    // cacheWillUpdate() method to determine cacheability of the response.
    const cacheable &#x3D; effectiveCacheableResponsePlugin.cacheWillUpdate(
      {request, response});

    if (cacheable) {
      // If cleanRedirects is set and this is a redirected response, then
      // get a &quot;clean&quot; copy to add to the cache.
      const newResponse &#x3D; cleanRedirects &amp;amp;&amp;amp; response.redirected ?
        await cleanResponseCopy({response}) :
        response.clone();

      // cachingComplete is a promise that may or may not be used to delay the
      // completion of this method, depending on the value of &#x60;waitOnCache&#x60;.
      cachingComplete &#x3D; this.getCache().then(async (cache) &#x3D;&gt; {
        let oldResponse;
        const cacheRequest &#x3D; cacheKey || request;

        // Only bother getting the old response if the new response isn&#x27;t opaque
        // and there&#x27;s at least one cacheDidUpdate plugin. Otherwise, we don&#x27;t
        // need it.
        if (response.type !&#x3D;&#x3D; &#x27;opaque&#x27; &amp;amp;&amp;amp;
          this.plugins.has(&#x27;cacheDidUpdate&#x27;)) {
          oldResponse &#x3D; await this.match({request: cacheRequest});
        }

        // Regardless of whether or not we&#x27;ll end up invoking
        // cacheDidUpdate, wait until the cache is updated.
        await cache.put(cacheRequest, newResponse);

        if (this.plugins.has(&#x27;cacheDidUpdate&#x27;)) {
          for (let plugin of this.plugins.get(&#x27;cacheDidUpdate&#x27;)) {
            await plugin.cacheDidUpdate({
              cacheName: this.cacheName,
              oldResponse,
              newResponse,
              // cacheRequest may be a Request with a url property, or a string.
              url: (&#x27;url&#x27; in cacheRequest) ? cacheRequest.url : cacheRequest,
            });
          }
        }
      });
    } else if (!cacheable &amp;amp;&amp;amp; waitOnCache) {
      // If the developer requested to wait on the cache but the response
      // isn&#x27;t cacheable, throw an error.
      throw ErrorFactory.createError(&#x27;invalid-response-for-caching&#x27;);
    }

    // Only conditionally await the caching completion, giving developers the
    // option of returning early for, e.g., read-through-caching scenarios.
    if (waitOnCache &amp;amp;&amp;amp; cachingComplete) {
      await cachingComplete;
    }

    return response;
  }
}

export default RequestWrapper;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>