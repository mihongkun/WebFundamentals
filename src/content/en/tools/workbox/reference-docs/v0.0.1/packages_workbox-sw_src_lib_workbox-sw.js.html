<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="_project.yaml" />
  <meta name="book_path" value="_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Source: packages/workbox-sw/src/lib/workbox-sw.js</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: packages/workbox-sw/src/lib/workbox-sw.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/*
 Copyright 2016 Google Inc. All Rights Reserved.
 Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/

/* eslint-env browser, serviceworker */

import ErrorFactory from &#x27;./error-factory.js&#x27;;
import Router from &#x27;./router.js&#x27;;
import Strategies from &#x27;./strategies&#x27;;
import environment from &#x27;../../../../lib/environment.js&#x27;;
import logHelper from &#x27;../../../../lib/log-helper&#x27;;
import {BroadcastCacheUpdatePlugin} from
  &#x27;../../../workbox-broadcast-cache-update/src/index.js&#x27;;
import {RevisionedCacheManager} from &#x27;../../../workbox-precaching/src/index.js&#x27;;
import {Route} from &#x27;../../../workbox-routing/src/index.js&#x27;;
import {
  getDefaultCacheName} from &#x27;../../../workbox-runtime-caching/src/index.js&#x27;;

/**
 * A high level library to make it as easy as possible to precache assets
 * efficiently and define run time caching strategies.
 *
 * @memberof module:workbox-sw
 */
class WorkboxSW {
  /**
   * You should instantiate this class with &#x60;new self.goog.SWLib()&#x60;.
   * @param {Object} input
   * @param {string} [input.cacheId] Defining a cacheId is useful to ensure
   * uniqueness across cache names. Useful if you have multiple sites served
   * over localhost.
   * @param {boolean} [input.clientsClaim] To claim currently open clients set
   * this value to true. (Defaults to false).
   * @param  {String} [input.directoryIndex]  The directoryIndex will
   * check cache entries for a URLs ending with &#x27;/&#x27; to see if there is a hit
   * when appending the directoryIndex (i.e. &#x27;/index.html&#x27;).
   * @param {string} [input.precacheChannelName] This value will be used as
   * the &#x60;channelName&#x60; to construct a {@link BroadcastCacheUpdate} plugin. The
   * plugin sends a message whenever a precached URL is updated. To disable this
   * plugin, set &#x60;precacheChannelName&#x60; to an empty string.
   * (Defaults to &#x60;&#x27;precache-updates&#x27;&#x60;)
   * @param {Array&amp;lt;RegExp&gt;} [input.ignoreUrlParametersMatching] An array of
   * regex&#x27;s to remove search params when looking for a cache match.
   */
  constructor({cacheId, clientsClaim, handleFetch,
               directoryIndex &#x3D; &#x27;index.html&#x27;,
               precacheChannelName &#x3D; &#x27;precache-updates&#x27;,
               ignoreUrlParametersMatching &#x3D; [/^utm_/]} &#x3D; {}) {
    if (!environment.isServiceWorkerGlobalScope()) {
      // If we are not running in a service worker, fail early.
      throw ErrorFactory.createError(&#x27;not-in-sw&#x27;);
    }

    if (environment.isDevBuild()) {
      if (environment.isLocalhost()) {
        // If this is a dev bundle on localhost, print a welcome message.
        logHelper.debug({
          message: &#x27;Welcome to Workbox!&#x27;,
          data: {
            &#x27;üìñ&#x27;: &#x27;Read the guides and documentation\n&#x27; +
              &#x27;https://googlechrome.github.io/workbox/&#x27;,
            &#x27;‚ùì&#x27;: &#x27;Use the [workbox] tag on StackOverflow to ask questions\n&#x27; +
              &#x27;https://stackoverflow.com/questions/ask?tags&#x3D;workbox&#x27;,
            &#x27;üêõ&#x27;: &#x27;Found a bug? Report it on GitHub\n&#x27; +
              &#x27;https://github.com/GoogleChrome/workbox/issues/new&#x27;,
          },
        });
      } else {
        // If this is a dev bundle not on localhost, recommend the prod bundle.
        logHelper.warn(&#x60;This appears to be a production server. Please switch
          to the smaller, optimized production build of Workbox.&#x60;);
      }
    }

    if (cacheId &amp;amp;&amp;amp; (typeof cacheId !&#x3D;&#x3D; &#x27;string&#x27; || cacheId.length &#x3D;&#x3D;&#x3D; 0)) {
      throw ErrorFactory.createError(&#x27;bad-cache-id&#x27;);
    }
    if (clientsClaim &amp;amp;&amp;amp; (typeof clientsClaim !&#x3D;&#x3D; &#x27;boolean&#x27;)) {
      throw ErrorFactory.createError(&#x27;bad-clients-claim&#x27;);
    }
    if (typeof directoryIndex !&#x3D;&#x3D; &#x27;undefined&#x27;) {
      if (directoryIndex &#x3D;&#x3D;&#x3D; false || directoryIndex &#x3D;&#x3D;&#x3D; null) {
        directoryIndex &#x3D; false;
      } else if (typeof directoryIndex !&#x3D;&#x3D; &#x27;string&#x27; ||
        directoryIndex.length &#x3D;&#x3D;&#x3D; 0) {
        throw ErrorFactory.createError(&#x27;bad-directory-index&#x27;);
      }
    }

    const plugins &#x3D; [];
    if (precacheChannelName) {
      plugins.push(new BroadcastCacheUpdatePlugin({
        channelName: precacheChannelName,
        source: registration &amp;amp;&amp;amp; registration.scope ?
          registration.scope :
          location,
      }));
    }

    this._runtimeCacheName &#x3D; getDefaultCacheName({cacheId});
    this._revisionedCacheManager &#x3D; new RevisionedCacheManager({
      cacheId,
      plugins,
    });
    this._strategies &#x3D; new Strategies({
      cacheId,
    });

    this._router &#x3D; new Router(
      this._revisionedCacheManager.getCacheName(),
      handleFetch
    );
    this._registerInstallActivateEvents(clientsClaim);
    this._registerDefaultRoutes(ignoreUrlParametersMatching, directoryIndex);
  }

  /**
   * Revisioned assets can be cached intelligently
   * during the install (i.e. old files are cleared from the cache, new files
   * are added to the cache and unchanged files are left as is).
   *
   * The input needs to be an array of URL strings which having revisioning
   * details in them otherwise the entry should be an object with &#x60;url&#x60; and
   * &#x60;revision&#x60; parameters.
   *
   * In addition to maintaining the cache, this method will also set up the
   * necessary routes to serve the precached assets using a cache-first
   * strategy.
   *
   * @example &amp;lt;caption&gt;Cache revisioned assets.&amp;lt;/caption&gt;
   * // Cache a set of revisioned URLs
   * const swlib &#x3D; new goog.SWLib();
   * swlib.precache([
   *     &#x27;/styles/main.613e6c7332dd83e848a8b00c403827ed.css&#x27;,
   *     &#x27;/images/logo.59a325f32baad11bd47a8c515ec44ae5.jpg&#x27;
   * ]);
   *
   * // ...precache() can also take objects to cache
   * // non-revisioned URLs.
   * // Please use workbox-build or workbox-cli to generate the manifest for
   * // you.
   * swlib.precache([
   *     {
   *       url: &#x27;/index.html&#x27;,
   *       revision: &#x27;613e6c7332dd83e848a8b00c403827ed&#x27;
   *     },
   *     {
   *       url: &#x27;/about.html&#x27;,
   *       revision: &#x27;59a325f32baad11bd47a8c515ec44ae5&#x27;
   *     }
   * ]);
   *
   * @param {Array&amp;lt;String|Object&gt;} revisionedFiles A set of urls to cache
   * when the service worker is installed.
   */
  precache(revisionedFiles) {
    // Add a more helpful error message than assertion error.
    if (!Array.isArray(revisionedFiles)) {
      throw ErrorFactory.createError(&#x27;bad-revisioned-cache-list&#x27;);
    }

    this._revisionedCacheManager.addToCacheList({
      revisionedFiles,
    });
  }

  /**
   * The router for this library is exposed via the &#x60;router&#x60; parameter.
   * This is an instance of the {@link module:workbox-sw.Router|Router}.
   *
   * @example
   * const swlib &#x3D; new goog.SWLib();
   * swlib.router.registerRoute(&#x27;/&#x27;, swlib.goog.cacheFirst());
   *
   * @type {Router}
   */
  get router() {
    return this._router;
  }

  /**
   * RuntimeStrategyOptions is just a JavaScript object, but the structure
   * explains the options for runtime strategies used in workbox-sw.
   *
   * See the example of how this can be used with the &#x60;cacheFirst()&#x60; caching
   * strategy.
   *
   * @example
   * const swlib &#x3D; new goog.SWLib();
   * const cacheFirstStrategy &#x3D; swlib.strategies.cacheFirst({
   *   cacheName: &#x27;example-cache&#x27;,
   *   cacheExpiration: {
   *     maxEntries: 10,
   *     maxAgeSeconds: 7 * 24 * 60 * 60
   *   },
   *   broadcastCacheUpdate: {
   *     channelName: &#x27;example-channel-name&#x27;
   *   },
   *   cacheableResponse: {
   *     statuses: [0, 200, 404],
   *     headers: {
   *       &#x27;Example-Header-1&#x27;: &#x27;Header-Value-1&#x27;,
   *       &#x27;Example-Header-2&#x27;: &#x27;Header-Value-2&#x27;
   *     }
   *   }
   *   plugins: [
   *     // Additional Plugins
   *   ]
   * });
   *
   * @typedef {Object} RuntimeStrategyOptions
   * @property {String} cacheName Name of cache to use
   * for caching (both lookup and updating).
   * @property {Object} cacheExpiration Defining this
   * object will add a cache expiration plugins to this strategy.
   * @property {Number} cacheExpiration.maxEntries
   * The maximum number of entries to store in a cache.
   * @property {Number} cacheExpiration.maxAgeSeconds
   * The maximum lifetime of a request to stay in the cache before it&#x27;s removed.
   * @property {Object} broadcastCacheUpdate Defining
   * this object will add a broadcast cache update plugin.
   * @property {String} broadcastCacheUpdate.channelName
   * The name of the broadcast channel to dispatch messages on.
   * @property {Array&amp;lt;plugins&gt;} plugins For
   * any additional plugins you wish to add, simply include them in this
   * array.
   * @property {Object} cacheableResponse Specifies types of responses to cache
   * by status codes, headers, or both.
   * @property {Array&amp;lt;Number&gt;} cacheableResponse.statuses An array of status
   * codes to cache.
   * @property {Array&amp;lt;Object&gt;} cacheableResponse.headers An array of
   * header-value paris for HTTP headers to cache. See the example, above.
   * @memberof module:workbox-sw.SWLib
   */

  /**
   * The supported caching strategies shipped with workbox-sw are provided via
   * the &#x60;strategies&#x60; object.
   * {@link module:workbox-sw.Strategies|See Strategies for a complete list}.
   *
   * @example
   * const swlib &#x3D; new goog.SWLib();
   * swlib.router.registerRoute(&#x27;/styles/*&#x27;,
   *  swlib.strategies.cacheFirst());
   */
  get strategies() {
    return this._strategies;
  }

  /**
   * The name of the cache used by default by the runtime caching strategies.
   *
   * Entries that are managed via &#x60;precache()&#x60; are stored in a separate cache
   * with a different name.
   *
   * You can override the default cache name when constructing a strategy if
   * you&#x27;d prefer, via
   * &#x60;swlib.strategies.cacheFirst({cacheName: &#x27;my-cache-name&#x27;});&#x60;
   *
   * If you would like to explicitly add to, remove, or check the contents of
   * the default cache, you can use the [Cache Storage API](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage)
   * to pass in the default cache name to &#x60;caches.open()&#x60;. This can be useful if
   * you want to &quot;prime&quot; your cache with remote resources that can&#x27;t be properly
   * managed via &#x60;precache()&#x60;.
   *
   * @example
   * const cache &#x3D; await caches.open(swlib.runtimeCacheName);
   * await cache.add(&#x27;https://third-party.com/path/to/file&#x27;);
   * const contentsOfRuntimeCache &#x3D; await cache.keys();
   */
  get runtimeCacheName() {
    return this._runtimeCacheName;
  }

  /**
   * This method will register listeners for the install and activate events.
   * @private
   * @param {boolean} clientsClaim Whether to claim clients in activate or not.
   */
  _registerInstallActivateEvents(clientsClaim) {
    self.addEventListener(&#x27;install&#x27;, (event) &#x3D;&gt; {
      const cachedUrls &#x3D; this._revisionedCacheManager.getCachedUrls();
      if (cachedUrls.length &gt; 0) {
        logHelper.debug({
          that: this,
          message: &#x60;The precached URLs will automatically be served using a
            cache-first strategy.&#x60;,
          data: {&#x27;Precached URLs&#x27;: JSON.stringify(cachedUrls)},
        });
      }

      event.waitUntil(this._revisionedCacheManager.install());
    });

    self.addEventListener(&#x27;activate&#x27;, (event) &#x3D;&gt; {
      event.waitUntil(
        this._revisionedCacheManager.cleanup()
        .then(() &#x3D;&gt; {
          if (clientsClaim) {
            return self.clients.claim();
          }
        })
      );
    });
  }

  /**
   * This method will register any default routes the library will need.
   * @private
   * @param {Array&amp;lt;RegExp&gt;} ignoreUrlParametersMatching An array of regex&#x27;s
   * used to remove search parameters which match on of them.
   * @param {string} directoryIndex The directory index is appended to URLs
   * ending with &#x27;/&#x27;.
   */
  _registerDefaultRoutes(ignoreUrlParametersMatching, directoryIndex) {
    const plugins &#x3D; [];

    // Add custom directory index plugin.
    if (ignoreUrlParametersMatching || directoryIndex) {
      plugins.push(
        this._getCacheMatchPlugin(ignoreUrlParametersMatching, directoryIndex)
      );
    }

    const cacheFirstHandler &#x3D; this.strategies.cacheFirst({
      cacheName: this._revisionedCacheManager.getCacheName(),
      plugins,
    });

    const route &#x3D; new Route({
      match: ({url}) &#x3D;&gt; {
        const cachedUrls &#x3D; this._revisionedCacheManager.getCachedUrls();
        if (cachedUrls.indexOf(url.href) !&#x3D;&#x3D; -1) {
          return true;
        }

        let strippedUrl &#x3D;
          this._removeIgnoreUrlParams(url.href, ignoreUrlParametersMatching);
        if (cachedUrls.indexOf(strippedUrl.href) !&#x3D;&#x3D; -1) {
          return true;
        }

        if (directoryIndex &amp;amp;&amp;amp; strippedUrl.pathname.endsWith(&#x27;/&#x27;)) {
          url.pathname +&#x3D; directoryIndex;
          return cachedUrls.indexOf(url.href) !&#x3D;&#x3D; -1;
        }

        return false;
      },
      handler: cacheFirstHandler,
    });
    this.router.registerRoute(route);
  }

  /**
   * @private
   * @param  {Array&amp;lt;RegExp&gt;} ignoreUrlParametersMatching An array of regex&#x27;s to
   * define which search parameters should be removed before looking for cache
   * match.
   * @param {string} directoryIndex The directory index is appended to URLs
   * ending with &#x27;/&#x27;.
   * @return {Promise&amp;lt;Object&gt;} Returns a plugin that attempts to match the
   * URL with /index.html
   */
  _getCacheMatchPlugin(ignoreUrlParametersMatching, directoryIndex) {
    const cacheMatchFunction &#x3D; async (
      {request, cache, cachedResponse, matchOptions}) &#x3D;&gt; {
      // If we already have a cache hit, then just return that.
      if (cachedResponse) {
        return cachedResponse;
      }

      let strippedUrl &#x3D;
        this._removeIgnoreUrlParams(request.url, ignoreUrlParametersMatching);
      return cache.match(strippedUrl.toString(), matchOptions)
      .then((response) &#x3D;&gt; {
        if (!response) {
          // Otherwise, try again with the indexHtmlString value.
          if (strippedUrl.pathname.endsWith(&#x27;/&#x27;)) {
            strippedUrl.pathname +&#x3D; directoryIndex;
            return cache.match(strippedUrl.toString(), matchOptions);
          }
        }

        return response;
      });
    };

    return {cacheWillMatch: cacheMatchFunction};
  }

  /**
   * @param {string} originalUrl The original url to remove the search params.
   * @param  {Array&amp;lt;RegExp&gt;} ignoreUrlParametersMatching An array of regex&#x27;s to
   * define which search parameters should be removed before looking for cache
   * match.
   * @return {string} An object that can be used as a plugin within a
   * RequestWrapper.
   */
  _removeIgnoreUrlParams(originalUrl, ignoreUrlParametersMatching) {
    const url &#x3D; new URL(originalUrl);

    // Exclude initial &#x27;?&#x27;
    const searchString &#x3D; url.search.slice(1);

    // Split into an array of &#x27;key&#x3D;value&#x27; strings
    const keyValueStrings &#x3D; searchString.split(&#x27;&amp;amp;&#x27;);
    const keyValuePairs &#x3D; keyValueStrings.map((keyValueString) &#x3D;&gt; {
      // Split each &#x27;key&#x3D;value&#x27; string into a [key, value] array
      return keyValueString.split(&#x27;&#x3D;&#x27;);
    });

    const filteredKeyValuesPairs &#x3D; keyValuePairs.filter((keyValuePair) &#x3D;&gt; {
      return ignoreUrlParametersMatching
        .every((ignoredRegex) &#x3D;&gt; {
          // Return true iff the key doesn&#x27;t match any of the regexes.
          return !ignoredRegex.test(keyValuePair[0]);
        });
    });
    const filteredStrings &#x3D; filteredKeyValuesPairs.map((keyValuePair) &#x3D;&gt; {
       // Join each [key, value] array into a &#x27;key&#x3D;value&#x27; string
      return keyValuePair.join(&#x27;&#x3D;&#x27;);
    });

    // Join the array of &#x27;key&#x3D;value&#x27; strings into a string with &#x27;&amp;amp;&#x27; in
    // between each
    url.search &#x3D; filteredStrings.join(&#x27;&amp;amp;&#x27;);

    return url;
  }
}

export default WorkboxSW;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>