<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="_project.yaml" />
  <meta name="book_path" value="_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Source: packages/workbox-build/src/lib/get-file-manifest-entries.js</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: packages/workbox-build/src/lib/get-file-manifest-entries.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>const errors &#x3D; require(&#x27;./errors&#x27;);
const filterFiles &#x3D; require(&#x27;./utils/filter-files&#x27;);
const getCompositeDetails &#x3D; require(&#x27;./utils/get-composite-details&#x27;);
const getFileDetails &#x3D; require(&#x27;./utils/get-file-details&#x27;);
const getStringDetails &#x3D; require(&#x27;./utils/get-string-details&#x27;);

/**
 * @typedef {Object} ManifestEntry
 * @property {String} url The URL to the asset in the manifest.
 * @property {String} revision The revision details for the file. This is a
 * hash generated by node based on the file contents.
 * @memberof module:workbox-build
 */


/**
 * To get a list of files and revision details that can be used to ultimately
 * precache assets in a service worker.
 *
 * @param {Object} input
 * @param {Array&amp;lt;String&gt;} input.staticFileGlobs Patterns used to select files to
 * include in the file entries.
 * @param {Array&amp;lt;String&gt;} [input.globIgnores] Patterns used to exclude files
 * from the file entries.
 * @param {String} input.globDirectory The directory run the glob patterns over.
 * @param {Object&amp;lt;String,Array|String&gt;} [input.templatedUrls]
 * If a URL is rendered/templated on the server, its contents may not depend on
 * a single file. This maps URLs to a list of file names, or to a string
 * value, that uniquely determines each URL&#x27;s contents.
 * @param {number} [input.maximumFileSizeToCacheInBytes] An optional number to
 * define the maximum file size to consider whether the file should be
 * precached. (Defaults to 2MB).
 * @param {RegExp} [input.dontCacheBustUrlsMatching] An optional regex that will
 * return a URL string and exclude the revision details for urls matching this
 * regex. Useful if you have assets with file revisions in the URL.
 * @return {Array&amp;lt;ManifestEntry&gt;} An array of ManifestEntries will include
 * a url and revision details for each file found.
 * @memberof module:workbox-build
 */
const getFileManifestEntries &#x3D; (input) &#x3D;&gt; {
  if (!input || typeof input !&#x3D;&#x3D; &#x27;object&#x27; || Array.isArray(input)) {
    throw new Error(errors[&#x27;invalid-get-manifest-entries-input&#x27;]);
  }

  const staticFileGlobs &#x3D; input.staticFileGlobs;
  const globIgnores &#x3D; input.globIgnores ? input.globIgnores : [];
  const globDirectory &#x3D; input.globDirectory;
  // dynamicUrlToDependencies is for workbox-precaching parity / migration.
  const templatedUrls &#x3D; input.templatedUrls || input.dynamicUrlToDependencies;

  if (typeof globDirectory !&#x3D;&#x3D; &#x27;string&#x27; || globDirectory.length &#x3D;&#x3D;&#x3D; 0) {
    return Promise.reject(
      new Error(errors[&#x27;invalid-glob-directory&#x27;]));
  }

  if (!staticFileGlobs || !Array.isArray(staticFileGlobs)) {
    return Promise.reject(
      new Error(errors[&#x27;invalid-static-file-globs&#x27;]));
  }

  if (!globIgnores || !Array.isArray(globIgnores)) {
    return Promise.reject(
      new Error(errors[&#x27;invalid-glob-ignores&#x27;]));
  }

  // templatedUrls is optional.
  if (templatedUrls &amp;amp;&amp;amp; (
      typeof templatedUrls !&#x3D;&#x3D; &#x27;object&#x27; || Array.isArray(templatedUrls))) {
      return Promise.reject(new Error(errors[&#x27;invalid-templated-urls&#x27;]));
  }

  let validIgnores &#x3D; true;
  globIgnores.forEach((pattern) &#x3D;&gt; {
    if (typeof pattern !&#x3D;&#x3D; &#x27;string&#x27;) {
      validIgnores &#x3D; false;
    }
  });
  if (!validIgnores) {
    return Promise.reject(
      new Error(errors[&#x27;invalid-glob-ignores&#x27;]));
  }

  const fileSet &#x3D; new Set();

  const fileDetails &#x3D; staticFileGlobs.reduce((accumulated, globPattern) &#x3D;&gt; {
    const globbedFileDetails &#x3D; getFileDetails(
      globDirectory, globPattern, globIgnores);
    globbedFileDetails.forEach((fileDetails) &#x3D;&gt; {
      if (fileSet.has(fileDetails.file)) {
        return;
      }

      fileSet.add(fileDetails.file);
      accumulated.push(fileDetails);
    });
    return accumulated;
  }, []);

  // templatedUrls is optional.
  if (templatedUrls) {
    for (let url of Object.keys(templatedUrls)) {
      if (fileSet.has(url)) {
        return Promise.reject(
          new Error(errors[&#x27;templated-url-matches-glob&#x27;]));
      }

      const dependencies &#x3D; templatedUrls[url];
      if (Array.isArray(dependencies)) {
        const dependencyDetails &#x3D; dependencies.reduce((previous, pattern) &#x3D;&gt; {
          try {
            const globbedFileDetails &#x3D; getFileDetails(
              globDirectory, pattern, globIgnores);
            return previous.concat(globbedFileDetails);
          } catch (err) {
            const debugObj &#x3D; {};
            debugObj[url] &#x3D; dependencies;
            throw new Error(&#x60;${errors[&#x27;bad-template-urls-asset&#x27;]} &#x60; +
              &#x60;&#x27;${pattern}&#x27; in templateUrl &#x27;${JSON.stringify(debugObj)}&#x27; &#x60; +
              &#x60;could not be found.&#x60;);
          }
        }, []);
        fileDetails.push(getCompositeDetails(url, dependencyDetails));
      } else if (typeof dependencies &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
        fileDetails.push(getStringDetails(url, dependencies));
      } else {
        return Promise.reject(
          new Error(errors[&#x27;invalid-templated-urls&#x27;]));
      }
    }
  }

  return Promise.resolve(filterFiles(fileDetails, input));
};

module.exports &#x3D; getFileManifestEntries;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>