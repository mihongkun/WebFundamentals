<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="_project.yaml" />
  <meta name="book_path" value="_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Source: packages/workbox-cli/src/index.js</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: packages/workbox-cli/src/index.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
**/

&#x27;use strict&#x27;;

const path &#x3D; require(&#x27;path&#x27;);
const updateNotifier &#x3D; require(&#x27;update-notifier&#x27;);
const workboxBuild &#x3D; require(&#x27;workbox-build&#x27;);

const cliLogHelper &#x3D; require(&#x27;./lib/log-helper&#x27;);
const generateGlobPattern &#x3D; require(&#x27;./lib/utils/generate-glob-pattern&#x27;);
const saveConfigFile &#x3D; require(&#x27;./lib/utils/save-config&#x27;);
const getConfig &#x3D; require(&#x27;./lib/utils/get-config&#x27;);
const errors &#x3D; require(&#x27;./lib/errors&#x27;);

const askForRootOfWebApp &#x3D; require(&#x27;./lib/questions/ask-root-of-web-app&#x27;);
const askForServiceWorkerSrc &#x3D; require(&#x27;./lib/questions/ask-sw-src&#x27;);
const askForServiceWorkerDest &#x3D; require(&#x27;./lib/questions/ask-sw-dest&#x27;);
const askSaveConfigFile &#x3D; require(&#x27;./lib/questions/ask-save-config&#x27;);
const askForExtensionsToCache &#x3D;
  require(&#x27;./lib/questions/ask-extensions-to-cache&#x27;);

/**
 * This class is a wrapper to make test easier. This is used by
 * ./bin/index.js to pass in the args when the CLI is used.
 */
class SWCli {
  /**
   * This is a helper method that allows the test framework to call argv with
   * arguments without worrying about running as an actual CLI.
   *
   * @private
   * @param {Object} meowOutput The value passed in via process.argv.
   * @return {Promise} Promise is returned so testing framework knows when
   * handling the request has finished.
   */
  argv(meowOutput) {
    updateNotifier({pkg: meowOutput.pkg}).notify();

    if (meowOutput.input.length &gt; 0) {
      // We have a command
      return this.handleCommand(
        meowOutput.input[0],
        meowOutput.input.splice(1),
        meowOutput.flags
      )
      .then(() &#x3D;&gt; {
        process.exit(0);
      })
      .catch((error) &#x3D;&gt; {
        cliLogHelper.error(error);
        process.exit(1);
      });
    } else {
      meowOutput.showHelp(1);
    }
  }

  /**
   * If a command is given in the command line args, this method will handle
   * the appropriate action.
   * @param {string} command The command name.
   * @param {object} args The arguments given to this command.
   * @param {object} flags The flags supplied with the command line.
   * @return {Promise} A promise for the provided task.
   */
  handleCommand(command, args, flags) {
    switch (command) {
      case &#x27;generate:sw&#x27;:
        return this._generateSW(flags);
      case &#x27;inject:manifest&#x27;:
        return this._injectManifest(flags);
      default:
        return Promise.reject(&#x60;Invalid command: &#x27;${command}&#x27;&#x60;);
    }
  }

  /**
   * This method will generate a working service worker with a file manifest.
   * @param {Object} flags The flags supplied as part of the CLI input.
   * @return {Promise} The promise returned here will be used to exit the
   * node process cleanly or not.
   */
  _generateSW(flags) {
    let config &#x3D; {};
    let configFile &#x3D; null;
    if (flags) {
      configFile &#x3D; flags.configFile;
      // Remove configFile from flags (if it was present) so that it doesn&#x27;t
      // trigger the &#x27;config-supplied-missing-fields&#x27; error later on.
      delete flags.configFile;
    }

    return getConfig(configFile)
    .then((savedConfig) &#x3D;&gt; {
      if (savedConfig) {
        config &#x3D; savedConfig;
      }
      config &#x3D; Object.assign(config, flags);
    })
    .then(() &#x3D;&gt; {
      const requiredFields &#x3D; [
        &#x27;globDirectory&#x27;,
        &#x27;globPatterns&#x27;,
        &#x27;swDest&#x27;,
      ];

      let askQuestions &#x3D; false;
      requiredFields.forEach((requiredField) &#x3D;&gt; {
        if (!config[requiredField]) {
          askQuestions &#x3D; true;
        }
      });

      if (askQuestions) {
        // If some configuration is defined but not all required fields
        // throw an error forcing the developer to either go through
        // the guided flow OR go through the config only flow.
        if (Object.keys(config).length &gt; 0) {
          cliLogHelper.error(errors[&#x27;config-supplied-missing-fields&#x27;] +
            requiredFields.join(&#x27;, &#x27;));
          return Promise.reject();
        }

        return this._askGenerateQuestions(config, requiredFields);
      }

      return Promise.resolve(config);
    })
    .then((config) &#x3D;&gt; {
      return workboxBuild.generateSW(config);
    });
  }

  /**
   * Ask questions required for input.
   * @param  {object} config The config options.
   * @param  {object} requiredFields The required fields to ask questions for.
   * @return {Promise&amp;lt;object&gt;} Promise resolves to the config object.
   */
  _askGenerateQuestions(config, requiredFields) {
    return Promise.resolve()
    .then(() &#x3D;&gt; {
      if (!config.globDirectory &amp;amp;&amp;amp;
        requiredFields.indexOf(&#x27;globDirectory&#x27;) !&#x3D;&#x3D; -1) {
        return askForRootOfWebApp()
        .then((rDirectory) &#x3D;&gt; {
          // This will give a pretty relative path:
          // &#x27;&#x27; &#x3D;&gt; &#x27;./&#x27;
          // &#x27;build&#x27; &#x3D;&gt; &#x27;./build/&#x27;
          config.globDirectory &#x3D;
            path.join(&#x27;.&#x27;, path.relative(process.cwd(), rDirectory), path.sep);
        });
      }
    })
    .then(() &#x3D;&gt; {
      if (!config.globPatterns &amp;amp;&amp;amp;
        requiredFields.indexOf(&#x27;globPatterns&#x27;) !&#x3D;&#x3D; -1) {
        return askForExtensionsToCache(config.globDirectory)
        .then((extensionsToCache) &#x3D;&gt; {
          config.globPatterns &#x3D; [
            generateGlobPattern(extensionsToCache),
          ];
        });
      }
    })
    .then(() &#x3D;&gt; {
      if (!config.swSrc &amp;amp;&amp;amp;
        requiredFields.indexOf(&#x27;swSrc&#x27;) !&#x3D;&#x3D; -1) {
        return askForServiceWorkerSrc()
        .then((swSrc) &#x3D;&gt; {
          config.swSrc &#x3D; swSrc;
        });
      }
    })
    .then(() &#x3D;&gt; {
      if (!config.swDest &amp;amp;&amp;amp;
        requiredFields.indexOf(&#x27;swDest&#x27;) !&#x3D;&#x3D; -1) {
        return askForServiceWorkerDest()
        .then((swDest) &#x3D;&gt; {
          config.swDest &#x3D; swDest;
        });
      }
    })
    .then(() &#x3D;&gt; {
      return askSaveConfigFile();
    })
    .then((saveConfig) &#x3D;&gt; {
      if (saveConfig) {
        return saveConfigFile(config);
      }
    })
    .then(() &#x3D;&gt; config);
  }

  /**
   * This function should ask questions or use config/flags to read in a sw
   * and inject the manifest into the destination service worker.
   * @param  {object} flags Flags from command line.
   * @return {Promise} Resolves on
   */
  _injectManifest(flags) {
    let config &#x3D; {};
    let configFile &#x3D; null;
    if (flags) {
      configFile &#x3D; flags.configFile;
      // Remove configFile from flags (if it was present) so that it doesn&#x27;t
      // trigger the &#x27;config-supplied-missing-fields&#x27; error later on.
      delete flags.configFile;
    }

    return getConfig(configFile)
    .then((savedConfig) &#x3D;&gt; {
      if (savedConfig) {
        config &#x3D; savedConfig;
      }
      config &#x3D; Object.assign(config, flags);
    })
    .then(() &#x3D;&gt; {
      const requiredFields &#x3D; [
        &#x27;swSrc&#x27;,
        &#x27;swDest&#x27;,
        &#x27;globDirectory&#x27;,
        &#x27;globPatterns&#x27;,
      ];

      let askQuestions &#x3D; false;
      requiredFields.forEach((requiredField) &#x3D;&gt; {
        if (!config[requiredField]) {
          askQuestions &#x3D; true;
        }
      });

      if (askQuestions) {
        // If some configuration is defined but not all required fields
        // throw an error forcing the developer to either go through
        // the guided flow OR go through the config only flow.
        if (Object.keys(config).length &gt; 0) {
          cliLogHelper.error(errors[&#x27;config-supplied-missing-fields&#x27;] +
            requiredFields.join(&#x27;, &#x27;));
          return Promise.reject();
        }

        return this._askGenerateQuestions(config, requiredFields);
      }

      return Promise.resolve(config);
    })
    .then((config) &#x3D;&gt; {
      return workboxBuild.injectManifest(config);
    });
  }
}

module.exports &#x3D; SWCli;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>