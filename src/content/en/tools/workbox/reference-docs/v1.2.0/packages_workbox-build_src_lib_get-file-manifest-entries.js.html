<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="_project.yaml" />
  <meta name="book_path" value="_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Source: packages/workbox-build/src/lib/get-file-manifest-entries.js</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: packages/workbox-build/src/lib/get-file-manifest-entries.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>&#x27;use strict&#x27;;

const errors &#x3D; require(&#x27;./errors&#x27;);
const filterFiles &#x3D; require(&#x27;./utils/filter-files&#x27;);
const getCompositeDetails &#x3D; require(&#x27;./utils/get-composite-details&#x27;);
const getFileDetails &#x3D; require(&#x27;./utils/get-file-details&#x27;);
const getStringDetails &#x3D; require(&#x27;./utils/get-string-details&#x27;);
const constants &#x3D; require(&#x27;./constants&#x27;);

/**
 * @typedef {Object} ManifestEntry
 * @property {String} url The URL to the asset in the manifest.
 * @property {String} revision The revision details for the file. This is a
 * hash generated by node based on the file contents.
 * @memberof module:workbox-build
 */


/**
 * To get a list of files and revision details that can be used to ultimately
 * precache assets in a service worker.
 *
 * @param {Object} input
 * @param {String} input.globDirectory The directory you wish to run the
 * &#x60;globPatterns&#x60; against.
 * @param {Array&amp;lt;String&gt;} input.globPatterns Files matching against any of
 * these glob patterns will be included in the file manifest.
 *
 * Defaults to [&#x27;**\/*.{js,css}&#x27;]
 * @param {String|Array&amp;lt;String&gt;} [input.globIgnores] Files matching against any
 * of these glob patterns will be excluded from the file manifest, even if the
 * file matches against a &#x60;globPatterns&#x60; pattern. Defaults to ignoring
 * &#x27;node_modules&#x27;.
 * @param {Object&amp;lt;String,Array|String&gt;} [input.templatedUrls]
 * If a URL is rendered with templates on the server, its contents may
 * depend on multiple files. This maps URLs to an array of file names, or to a
 * string value, that uniquely determines the URL&#x27;s contents.
 * @param {String} [input.modifyUrlPrefix] An object of key value pairs
 * where URL&#x27;s starting with the key value will be replaced with the
 * corresponding value.
 * @param {number} [input.maximumFileSizeToCacheInBytes] This value can be used
 * to determine the maximum size of files that will be precached.
 *
 * Defaults to 2MB.
 * @param {RegExp} [input.dontCacheBustUrlsMatching] An optional regex that will
 * return a URL string and exclude the revision details for urls matching this
 * regex. Useful if you have assets with file revisions in the URL.
 * @param {Array&amp;lt;ManifestTransform&gt;} [input.manifestTransforms] A list of
 * manifest transformations, which will be applied sequentially against the
 * generated manifest. If &#x60;modifyUrlPrefix&#x60; or &#x60;dontCacheBustUrlsMatching&#x60; are
 * also specified, their corresponding transformations will be applied first.
 * @return {Promise&amp;lt;Array&amp;lt;ManifestEntry&gt;&gt;}
 * An array of {@link module:workbox-build#ManifestEntry|ManifestEntries}
 * which will include a url and revision parameter.
 * @memberof module:workbox-build
 */
const getFileManifestEntries &#x3D; (input) &#x3D;&gt; {
  if (!input || typeof input !&#x3D;&#x3D; &#x27;object&#x27; || Array.isArray(input)) {
    return Promise.reject(
      new Error(errors[&#x27;invalid-get-manifest-entries-input&#x27;]));
  }

  // staticFileGlobs is to ease workbox to sw-precache migration.
  if (input.globPatterns &amp;amp;&amp;amp; input.staticFileGlobs) {
    return Promise.reject(
      new Error(errors[&#x27;both-glob-patterns-static-file-globs&#x27;]));
  }

  let globPatterns &#x3D; input.globPatterns || input.staticFileGlobs;
  if (typeof input.globPatterns &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27; &amp;amp;&amp;amp;
    typeof input.staticFileGlobs &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;) {
    globPatterns &#x3D; constants.defaultGlobPatterns;
  }

  const globIgnores &#x3D; input.globIgnores || constants.defaultGlobIgnores;
  const globDirectory &#x3D; input.globDirectory;

  // dynamicUrlToDependencies is to ease workbox to sw-precache migration.
  if (input.templatedUrls &amp;amp;&amp;amp; input.dynamicUrlToDependencies) {
    return Promise.reject(
      new Error(errors[&#x27;both-templated-urls-dynamic-urls&#x27;]));
  }
  const templatedUrls &#x3D; input.templatedUrls || input.dynamicUrlToDependencies;

  if (typeof globDirectory !&#x3D;&#x3D; &#x27;string&#x27; || globDirectory.length &#x3D;&#x3D;&#x3D; 0) {
    return Promise.reject(
      new Error(errors[&#x27;invalid-glob-directory&#x27;]));
  }

  if (!globPatterns || !Array.isArray(globPatterns)) {
    return Promise.reject(
      new Error(errors[&#x27;invalid-static-file-globs&#x27;]));
  }

  if (!globIgnores || !Array.isArray(globIgnores)) {
    return Promise.reject(
      new Error(errors[&#x27;invalid-glob-ignores&#x27;]));
  }

  // templatedUrls is optional.
  if (templatedUrls &amp;amp;&amp;amp; (
      typeof templatedUrls !&#x3D;&#x3D; &#x27;object&#x27; || Array.isArray(templatedUrls))) {
      return Promise.reject(new Error(errors[&#x27;invalid-templated-urls&#x27;]));
  }

  let validIgnores &#x3D; true;
  globIgnores.forEach((pattern) &#x3D;&gt; {
    if (typeof pattern !&#x3D;&#x3D; &#x27;string&#x27;) {
      validIgnores &#x3D; false;
    }
  });
  if (!validIgnores) {
    return Promise.reject(
      new Error(errors[&#x27;invalid-glob-ignores&#x27;]));
  }

  const fileSet &#x3D; new Set();

  const fileDetails &#x3D; globPatterns.reduce((accumulated, globPattern) &#x3D;&gt; {
    const globbedFileDetails &#x3D; getFileDetails(
      globDirectory, globPattern, globIgnores);
    globbedFileDetails.forEach((fileDetails) &#x3D;&gt; {
      if (fileSet.has(fileDetails.file)) {
        return;
      }

      fileSet.add(fileDetails.file);
      accumulated.push(fileDetails);
    });
    return accumulated;
  }, []);

  // templatedUrls is optional.
  if (templatedUrls) {
    for (let url of Object.keys(templatedUrls)) {
      if (fileSet.has(url)) {
        return Promise.reject(
          new Error(errors[&#x27;templated-url-matches-glob&#x27;]));
      }

      const dependencies &#x3D; templatedUrls[url];
      if (Array.isArray(dependencies)) {
        try {
          const dependencyDetails &#x3D; dependencies.reduce((previous, pattern) &#x3D;&gt; {
            try {
              const globbedFileDetails &#x3D; getFileDetails(
                globDirectory, pattern, globIgnores);
              return previous.concat(globbedFileDetails);
            } catch (err) {
              const debugObj &#x3D; {};
              debugObj[url] &#x3D; dependencies;
              throw new Error(&#x60;${errors[&#x27;bad-template-urls-asset&#x27;]} &#x60; +
                  &#x60;&#x27;${pattern}&#x27; in templateUrl &#x27;${JSON.stringify(debugObj)}&#x27; &#x60; +
                  &#x60;could not be found.&#x60;);
            }
          }, []);
          fileDetails.push(getCompositeDetails(url, dependencyDetails));
        } catch (err) {
          return Promise.reject(err);
        }
      } else if (typeof dependencies &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
        fileDetails.push(getStringDetails(url, dependencies));
      } else {
        return Promise.reject(
          new Error(errors[&#x27;invalid-templated-urls&#x27;]));
      }
    }
  }

  return Promise.resolve(filterFiles(fileDetails, input));
};

module.exports &#x3D; getFileManifestEntries;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>