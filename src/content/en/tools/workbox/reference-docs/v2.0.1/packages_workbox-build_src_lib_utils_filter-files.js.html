<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="_project.yaml" />
  <meta name="book_path" value="_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Source: packages/workbox-build/src/lib/utils/filter-files.js</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: packages/workbox-build/src/lib/utils/filter-files.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>&#x27;use strict&#x27;;

const constants &#x3D; require(&#x27;../constants&#x27;);
const errors &#x3D; require(&#x27;../errors&#x27;);
const logHelper &#x3D; require(&#x27;../log-helper&#x27;);
const modifyUrlPrefixTranform &#x3D; require(&#x27;./modify-url-prefix-transform&#x27;);
const noRevisionForUrlsMatchingTransform &#x3D;
  require(&#x27;./no-revision-for-urls-matching-transform&#x27;);

/**
 * A &#x60;ManifestTransform&#x60; function can be used to modify the modify the &#x60;url&#x60; or
 * &#x60;revision&#x60; properties of some or all of the
 * {@link module:workbox-build#ManifestEntry|ManifestEntries} in the manifest.
 *
 * Deleting the &#x60;revision&#x60; property of an entry will cause
 * the corresponding &#x60;url&#x60; to be precached without cache-busting parameters
 * applied, which is to say, it implies that the URL itself contains
 * proper versioning info. If the &#x60;revision&#x60; property is present, it must be
 * set to a string.
 *
 * @example &amp;lt;caption&gt;A transformation that prepended the origin of a CDN for any
 * URL starting with &#x27;/assets/&#x27; could be implemented as:&amp;lt;/caption&gt;
 *
 * const cdnTransform &#x3D; (manifestEntries) &#x3D;&gt; manifestEntries.map(entry &#x3D;&gt; {
 *   const cdnOrigin &#x3D; &#x27;https://example.com&#x27;;
 *   if (entry.url.startsWith(&#x27;/assets/&#x27;)) {
 *     entry.url &#x3D; cdnOrigin + entry.url;
 *   }
 *   return entry;
 * });
 *
 * @example &amp;lt;caption&gt;A transformation that removes the revision field when the
 * URL contains an 8-character hash surrounded by &#x27;.&#x27;, indicating that it
 * already contains revision information:&amp;lt;/caption&gt;
 *
 * const removeRevisionTransform &#x3D; (manifestEntries) &#x3D;&gt; {
 *   return manifestEntries.map(entry &#x3D;&gt; {
 *     const hashRegExp &#x3D; /\.\w{8}\./;
 *     if (entry.url.match(hashRegExp)) {
 *       delete entry.revision;
 *     }
 *     return entry;
 *   });
 * };
 *
 * @callback ManifestTransform
 * @param {Array&amp;lt;ManifestEntry&gt;} manifestEntries The full array of entries,
 * prior to the current transformation.
 * @return {Array&amp;lt;ManifestEntry&gt;} The array of entries with the transformation
 * applied.
 * @memberof module:workbox-build
 */

module.exports &#x3D; (fileDetails, options) &#x3D;&gt; {
  const maximumFileSize &#x3D; options.maximumFileSizeToCacheInBytes ||
    constants.maximumFileSize;
  const filteredFileDetails &#x3D; fileDetails.filter((fileDetails) &#x3D;&gt; {
    // Remove oversized files.
    if (fileDetails.size &gt; maximumFileSize) {
      logHelper.warn(&#x60;Skipping file &#x27;${fileDetails.file}&#x27; due to size. &#x60; +
        &#x60;[Max size supported is ${maximumFileSize}, this file is &#x60; +
        &#x60;${fileDetails.size}]&#x60;);
      return false;
    }

    return true;
  });

  // Take the array of fileDetail objects and convert it into an array of
  // {url, revision} objects, with path.sep replaced with /.
  const normalizedManifest &#x3D; filteredFileDetails.map((fileDetails) &#x3D;&gt; {
    return {
      url: fileDetails.file.replace(/\\/g, &#x27;/&#x27;),
      revision: fileDetails.hash,
    };
  });

  let manifestTransforms &#x3D; [];

  if (options.modifyUrlPrefix) {
    manifestTransforms.push(modifyUrlPrefixTranform(options.modifyUrlPrefix));
  }

  if (options.dontCacheBustUrlsMatching) {
    manifestTransforms.push(
      noRevisionForUrlsMatchingTransform(options.dontCacheBustUrlsMatching));
  }

  if (options.manifestTransforms) {
    if (Array.isArray(options.manifestTransforms)) {
      manifestTransforms &#x3D; manifestTransforms.concat(
        options.manifestTransforms
      );
    } else {
      throw new Error(errors[&#x27;bad-manifest-transforms&#x27;]);
    }
  }

  // Apply the transformations sequentially, and return the result.
  return manifestTransforms.reduce(
    (previousManifest, transform) &#x3D;&gt; transform(previousManifest),
    normalizedManifest);
};
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>