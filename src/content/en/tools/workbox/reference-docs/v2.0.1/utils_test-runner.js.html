<!DOCTYPE html>
<html devsite>

<head>
  <meta name="project_path" value="_project.yaml" />
  <meta name="book_path" value="_book.yaml" />
  <meta name="gtm_var" data-key="docType" data-value="reference">
  <title>Source: utils/test-runner.js</title>
  <link href="jsdoc.css" rel="stylesheet">
</head>

<body>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: utils/test-runner.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>const path &#x3D; require(&#x27;path&#x27;);
const chalk &#x3D; require(&#x27;chalk&#x27;);
const glob &#x3D; require(&#x27;glob&#x27;);
const seleniumAssistant &#x3D; require(&#x27;selenium-assistant&#x27;);
const swTestingHelpers &#x3D; require(&#x27;sw-testing-helpers&#x27;);

const testServerGen &#x3D; require(&#x27;./test-server-generator.js&#x27;);

/* eslint-disable no-console, require-jsdoc, no-invalid-this, max-len */
/* eslint-env mocha */

class TestRunner {
  constructor(packageNames) {
    this._packagePathsToTest &#x3D; packageNames.map((packageName) &#x3D;&gt; {
      return path.join(__dirname, &#x27;..&#x27;, &#x27;packages&#x27;, packageName);
    });
  }

  printHeading(heading) {
    console.log(chalk.inverse(&#x60;\n  ☢️  ${heading}  &#x60;));
  }

  start() {
    const that &#x3D; this;

    describe(&#x27;Test Runner Environment&#x27;, function() {
      let testServer;

      before(function() {
        that.printHeading(&#x60;Starting test server&#x60;);

        testServer &#x3D; testServerGen();
        return testServer.start(&#x27;.&#x27;)
        .then((portNumber) &#x3D;&gt; {
          that._baseTestUrl &#x3D; &#x60;http://localhost:${portNumber}&#x60;;
        });
      });

      // Kill the web server once all tests are complete.
      after(function() {
        that.printHeading(&#x60;Killing test server&#x60;);
        return testServer.stop();
      });

      const getBaseTestUrl &#x3D; () &#x3D;&gt; {
        return that._baseTestUrl;
      };

      that._configureBrowserTests(getBaseTestUrl);

      that._configureNodeTests(getBaseTestUrl);
    });
  }

  _configureBrowserTests(getBaseTestUrl) {
    if (!this._testsRequireBrowser()) {
      return;
    }

    const availableBrowsers &#x3D; seleniumAssistant.getLocalBrowsers();
    availableBrowsers.forEach((browser) &#x3D;&gt; {
      switch (browser.getId()) {
        case &#x27;chrome&#x27;:
        case &#x27;firefox&#x27;:
          if (browser.getId() &#x3D;&#x3D;&#x3D; &#x27;firefox&#x27; &amp;amp;&amp;amp;
            browser.getReleaseName() &#x3D;&#x3D;&#x3D; &#x27;unstable&#x27;) {
            return;
          }
          this._addBrowserTests(browser, getBaseTestUrl);
          break;
      }
    });
  }

  _addBrowserTests(browser, getBaseTestUrl) {
    const that &#x3D; this;
    describe(&#x60;&#x60;, function() {
      let webdriverInstance;
      before(function() {
        that.printHeading(&#x60;Starting browser tests in ${browser.getPrettyName()} - ${browser.getVersionNumber()}&#x60;);
      });

      after(function() {
        // Killing a web driver can be slow...
        this.timeout(10 * 1000);

        return seleniumAssistant.killWebDriver(webdriverInstance);
      });

      it(&#x27;should be able to get a valid webdriver instance&#x27;, function() {
        // Starting a web driver can be slow...
        this.timeout(10 * 1000);
        this.retries(2);

        return browser.getSeleniumDriver()
        .then((driver) &#x3D;&gt; {
          webdriverInstance &#x3D; driver;
        });
      });

      const getWebdriver &#x3D; () &#x3D;&gt; {
        return webdriverInstance;
      };

      that._packagePathsToTest.forEach((packagePath) &#x3D;&gt; {
        if (that._hasBrowserTests(packagePath)) {
          that._runBrowserTests(getWebdriver, packagePath, getBaseTestUrl, browser.getPrettyName());
        } else if (process.env.TRAVIS) {
          console.log(&#x27;No browser tests.&#x27;);
        }

        if (that._hasServiceWorkerTests(packagePath)) {
          that._runServiceWorkerTests(getWebdriver, packagePath, getBaseTestUrl, browser.getPrettyName());
        } else if (process.env.TRAVIS) {
          console.log(&#x27;No service worker tests.&#x27;);
        }

        if (that._hasIntegrationTests(packagePath)) {
          that._runIntegrationTests(getWebdriver, packagePath, getBaseTestUrl, browser.getPrettyName());
        } else if (process.env.TRAVIS) {
          console.log(&#x27;No integration tests.&#x27;);
        }
      });
    });
  }

  _handleMochaResults(testResults) {
    if (process.env.TRAVIS || testResults.failed.length &gt; 0) {
      console.log(
        swTestingHelpers.mochaUtils.prettyPrintResults(testResults)
      );
    }

    if (testResults.failed.length &gt; 0) {
      throw new Error(&#x60;${testResults.failed.length} test${testResults.failed.length &gt; 1 ? &#x27;s&#x27; : &#x27;&#x27;} failed.&#x60;);
    }
  }

  _testsRequireBrowser() {
    let hasBrowserTests &#x3D; false;
    for (let i &#x3D; 0; i &amp;lt; this._packagePathsToTest.length &amp;amp;&amp;amp; !hasBrowserTests; i++) {
      const packagePath &#x3D; this._packagePathsToTest[i];
      hasBrowserTests &#x3D; this._hasBrowserTests(packagePath) ||
        this._hasServiceWorkerTests(packagePath) ||
        this._hasIntegrationTests(packagePath);
    }
    return hasBrowserTests;
  }

  _testsRequireNode() {
    let hasNodeTests &#x3D; false;
    for (let i &#x3D; 0; i &amp;lt; this._packagePathsToTest.length &amp;amp;&amp;amp; !hasNodeTests; i++) {
      const packagePath &#x3D; this._packagePathsToTest[i];
      hasNodeTests &#x3D; this._hasNodeTests(packagePath);
    }
    return hasNodeTests;
  }

  _hasServiceWorkerTests(packagePath) {
    return glob.sync(&#x60;${packagePath}/test/sw/*.js&#x60;).length &gt; 0;
  }

  _hasBrowserTests(packagePath) {
    return glob.sync(&#x60;${packagePath}/test/browser/*.js&#x60;).length &gt; 0;
  }

  _hasIntegrationTests(packagePath) {
    return glob.sync(&#x60;${packagePath}/test/integration/*.js&#x60;).length &gt; 0;
  }

  _hasNodeTests(packagePath) {
    return glob.sync(&#x60;${packagePath}/test/node/*.js&#x60;).length &gt; 0;
  }

  _runBrowserTests(webdriverCb, packagePath, getBaseTestUrl, browserName) {
    const that &#x3D; this;
    it(&#x60;should pass &#x27;${path.basename(packagePath)}&#x27; browser tests in ${browserName}&#x60;, function() {
      this.timeout(10 * 1000);

      const webdriver &#x3D; webdriverCb();
      if (!webdriver) {
        console.warn(&#x27;Skipping selenium test due to no webdriver.&#x27;);
        return;
      }

      return swTestingHelpers.mochaUtils.startWebDriverMochaTests(
        path.basename(packagePath),
        webdriver,
        &#x60;${getBaseTestUrl()}/__test/mocha/browser/${path.basename(packagePath)}&#x60;
      )
      .then(that._handleMochaResults);
    });
  }

  _runServiceWorkerTests(webdriverCb, packagePath, getBaseTestUrl, browserName) {
    const that &#x3D; this;
    it(&#x60;should pass &#x27;${path.basename(packagePath)}&#x27; sw tests in ${browserName}&#x60;, function() {
      this.timeout(10 * 1000);

      const webdriver &#x3D; webdriverCb();
      if (!webdriver) {
        console.warn(&#x27;Skipping selenium test due to no webdriver.&#x27;);
        return;
      }

      return swTestingHelpers.mochaUtils.startWebDriverMochaTests(
        path.basename(packagePath),
        webdriver,
        &#x60;${getBaseTestUrl()}/__test/mocha/sw/${path.basename(packagePath)}&#x60;
      )
      .then(that._handleMochaResults);
    });
  }

  _runIntegrationTests(webdriverCb, packagePath, getBaseTestUrl, browserName) {
    const integrationTests &#x3D; glob.sync(&#x60;${packagePath}/test/integration/*.js&#x60;);
    global.getBaseTestUrl &#x3D; getBaseTestUrl;
    integrationTests.forEach((testFile) &#x3D;&gt; {
      const testCb &#x3D; require(testFile);
      testCb(webdriverCb);
    });
  }

  _configureNodeTests(getBaseTestUrl) {
    if (!this._testsRequireNode()) {
      return;
    }

    const that &#x3D; this;
    describe(&#x60;&#x60;, function() {
      before(function() {
        that.printHeading(&#x60;Starting Node tests&#x60;);
      });

      that._packagePathsToTest.forEach((packagePath) &#x3D;&gt; {
        if (that._hasNodeTests(packagePath)) {
          describe(&#x60;Node Tests for ${path.basename(packagePath)}&#x60;, function() {
            that._runNodeTests(packagePath, getBaseTestUrl);
          });
        } else if (process.env.TRAVIS) {
          console.log(&#x27;No node tests.&#x27;);
        }
      });
    });
  }

  _runNodeTests(packagePath, getBaseTestUrl) {
    const nodeTests &#x3D; glob.sync(&#x60;${packagePath}/test/node/*.js&#x60;);
    global.getBaseTestUrl &#x3D; getBaseTestUrl;
    nodeTests.forEach((nodeTextFile) &#x3D;&gt; {
      require(nodeTextFile);
    });
  }
}

module.exports &#x3D; TestRunner;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
</body>

</html>